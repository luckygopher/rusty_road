### 一：基础概念
#### 所有权规则
- 每个值都有一个变量，这个变量是该值的所有者
- 每个值同时只能有一个所有者
- 当所有者超出作用域时，该值将被删除

#### rust 内存释放
在变量离开作用域时，自动调用drop函数来释放资源并进行清理工作

#### String类型
- 字符串字面值: 在编译时就知道它的内容，其文本内容直接被硬编码到最终的可执行文件里
  - 值不可变，因此速度块、高效
- String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容
  - 一个String包含3个部分：1、指向存放字符串内容的内存的指针 2、长度 3、容量
  - String类型数据的描述信息放在 stack 上
  - 存放字符串内容的部分在 heap 上
  - 操作系统必须在运行时请求内存，通过调用 String::from 来实现

#### 移动（Move）
```
let str1 = String::from("hello");
let str2 = str1;
```
- 为了保证内存安全，避免二次释放(double free):
  - 当把str1赋给str2时，仅会复制stack上的数据描述信息，不会复制指针所指向的heap上的内存。
  - 当str1离开作用域的时候，会让str1失效，也不需要释放任何资源。
  - 在str2离开作用域的时候，才会进行资源释放。
  
![Memory Layout](images/move_img.png)

> [!Tip]
> 也可以将以上内容理解为浅拷贝(shallow copy)，但rust同时还会让str1失效。如果需要实现深拷贝(deep copy)，可使用clone方法

![Memory Layout](images/clone_img.png)

#### Stack上的数据: 复制
- Copy trait, 可以用于像整数一样的简单值，完全存放在stack上面的类型
- 如果一个类型实现了Copy这个trait，那么旧的变量在赋值后不需要 clone 也仍然可用
- 如果一个类型或者该类型的一部分实现了Drop trait，那么Rust不允许让它再实现Copy trait

#### 函数的参数与返回值
- 在语义上，将值传递给函数和把值赋给变量是类型的，将值传递给函数将会发生移动或复制。
- 函数在返回值的过程中同样也会发生所有权的转移

> [!IMPORTANT]
> 
> 一个变量的所有权总是遵循同样的模式：
> - 把一个值赋给其它变量时就会发生移动
> - 当一个包含heap数据的变量离开作用域时，它的值就会被drop函数清理，除非数据的所有权移动到另一个变量上了

#### 引用与借用
- 参数的类型是 &String 而不是String
- & 符号就表示引用，允许你引用某些值而不取得其所有权
- 我们把引用作为函数参数这个行为叫做借用
- 和变量一样，引用默认也是不可变的

![Memory Layout](images/quote_img.png)

#### 可变引用
- 引用使用 &mut 可以成为可变引用
- 在特定作用域内，对某一块数据，只能有一个可变的引用
- 可以通过创建新的作用域，来允许非同时的创建多个可变引用

#### 引用的规则
- 在任何给定的时刻，只能满足下列条件之一：
  - 一个可变的引用
  - 任意数量的不可变引用
- 引用必须一直有效，否则会出现悬空指针，编译会报错

#### 切片(slice)
- slice 是一种不持有所有权的数据类型
- 字符串切片是指向字符串中一部分内容的引用
- 字符串字面值的数据类型就是字符串切片(&str)
- 切片的索引遵循 左闭右开 原则

![Memory Layout](images/slice_img.png)